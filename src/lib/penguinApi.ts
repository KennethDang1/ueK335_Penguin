import {
  QueryKey,
  useMutation,
  UseMutationOptions,
  useQuery,
  useQueryClient,
} from "@tanstack/react-query";
import { useAuth } from "./AuthProvider";

// --- 1. Constants & Types ---
const API_BASE_URL = process.env.EXPO_PUBLIC_API_BASE_URL;

const PENGUINS_ENDPOINT = `${API_BASE_URL}/penguins`;

export const PENGUINS_QUERY_KEY: QueryKey = ["penguins"];

// Type for the raw data structure from the API
export interface ApiPenguin {
  id: number;
  Species: string;
  Island: string;
  "Beak Length (mm)": number | null;
  "Beak Depth (mm)": number | null;
  "Flipper Length (mm)": number | null;
  "Body Mass (g)": number | null;
  Sex: "MALE" | "FEMALE" | null;
  Name?: string | null;
}

// Clean, camelCase type for use within the React application
export interface Penguin {
  id: number;
  species: string;
  island: string;
  beakLengthMm: number | null;
  beakDepthMm: number | null;
  flipperLengthMm: number | null;
  bodyMassG: number | null;
  sex: "MALE" | "FEMALE" | null;
  name: string | null;
}

// Type for creating a new penguin (id is auto-generated by the server)
export type PenguinCreateData = Omit<Penguin, "id"> & { name: string | null };

// Type for updating a penguin (all fields are optional)
export type PenguinUpdateData = Partial<PenguinCreateData>;

// --- Helper types for local processing ---
export interface SortConfig {
  field: keyof Penguin;
  direction: "asc" | "desc";
}

export interface PaginationConfig {
  page: number;
  pageSize: number;
}

export interface FilterConfig {
  /** A general search query to filter by name or species */
  searchQuery?: string;
  gender?: "ALL" | "MALE" | "FEMALE";
}

export interface UsePenguinsParams {
  sort?: SortConfig;
  pagination?: PaginationConfig;
  filters?: FilterConfig;
}

// --- Data Mapping Functions ---

const mapApiToPenguin = (apiData: ApiPenguin): Penguin => ({
  id: apiData.id,
  species: apiData.Species,
  island: apiData.Island,
  beakLengthMm: apiData["Beak Length (mm)"],
  beakDepthMm: apiData["Beak Depth (mm)"],
  flipperLengthMm: apiData["Flipper Length (mm)"],
  bodyMassG: apiData["Body Mass (g)"],
  sex: apiData.Sex,
  name: apiData.Name ?? null,
});

/**
 * Maps our clean, internal format back to the API's format.
 * @param penguinData The clean penguin data from our app.
 */
const mapPenguinToApi = (
  penguinData: PenguinCreateData | PenguinUpdateData
): Partial<ApiPenguin> => ({
  Species: penguinData.species,
  Island: penguinData.island,
  "Beak Length (mm)": penguinData.beakLengthMm,
  "Beak Depth (mm)": penguinData.beakDepthMm,
  "Flipper Length (mm)": penguinData.flipperLengthMm,
  "Body Mass (g)": penguinData.bodyMassG,
  Sex: penguinData.sex,
  Name: penguinData.name,
});

const getAuthHeaders = (token: string): HeadersInit => ({
  "Content-Type": "application/json",
  Authorization: `Bearer ${token}`,
});

// --- API Fetching Functions ---

export const fetchPenguins = async (token: string): Promise<Penguin[]> => {
  const response = await fetch(PENGUINS_ENDPOINT, {
    headers: getAuthHeaders(token),
  });
  if (!response.ok) throw new Error("Failed to fetch penguins");
  const apiData: ApiPenguin[] = await response.json();
  return apiData.map(mapApiToPenguin);
};

export const createPenguin = async (
  penguinData: PenguinCreateData,
  token: string
): Promise<Penguin> => {
  const response = await fetch(PENGUINS_ENDPOINT, {
    method: "POST",
    headers: getAuthHeaders(token),
    body: JSON.stringify(mapPenguinToApi(penguinData)),
  });
  if (!response.ok) throw new Error("Failed to create penguin");
  const newApiPenguin: ApiPenguin = await response.json();
  return mapApiToPenguin(newApiPenguin);
};

export const updatePenguin = async ({
  id,
  penguinData,
  token,
}: {
  id: number;
  penguinData: PenguinUpdateData;
  token: string;
}): Promise<Penguin> => {
  const response = await fetch(`${PENGUINS_ENDPOINT}/${id}`, {
    method: "PUT",
    headers: getAuthHeaders(token),
    body: JSON.stringify(mapPenguinToApi(penguinData)),
  });
  if (!response.ok) throw new Error("Failed to update penguin");
  const updatedApiPenguin: ApiPenguin = await response.json();
  return mapApiToPenguin(updatedApiPenguin);
};

export const deletePenguin = async ({
  id,
  token,
}: {
  id: number;
  token: string;
}): Promise<void> => {
  const response = await fetch(`${PENGUINS_ENDPOINT}/${id}`, {
    method: "DELETE",
    headers: getAuthHeaders(token),
  });
  if (!response.ok) throw new Error("Failed to delete penguin");
};

// --- React Query Hooks ---

/**
 * Custom hook to fetch, filter, sort, and paginate penguin data.
 * @param {UsePenguinsParams} [params] - Optional parameters for sorting, pagination, and filtering.
 * @returns {object} An object containing:
 *   - `penguins`: The processed list of `Penguin` objects.
 *   - `totalCount`: The total number of penguins after filtering.
 *   - `totalPages`: The total number of pages based on pagination settings.
 *   - Standard `useQuery` return values like `isLoading`, `error`, etc.
 * @throws {Error} If the authentication token is not available.
 */
export const usePenguins = ({
  sort,
  pagination,
  filters,
}: UsePenguinsParams = {}) => {
  const { session } = useAuth();
  const token = session?.accessToken;

  return useQuery({
    queryKey: PENGUINS_QUERY_KEY,
    queryFn: () => {
      if (!token) throw new Error("Authentication token is not available.");
      return fetchPenguins(token);
    },
    enabled: !!token,
    staleTime: Infinity,
    gcTime: Infinity,
    select: (allPenguins: Penguin[]) => {
      let processedPenguins = [...allPenguins];

      if (filters?.searchQuery && filters.searchQuery.trim() !== "") {
        const query = filters.searchQuery.toLowerCase();
        processedPenguins = processedPenguins.filter(
          (p) =>
            p.name?.toLowerCase().includes(query) ||
            p.species.toLowerCase().includes(query) ||
            p.island.toLowerCase().includes(query)
        );
      }

      if (filters?.gender && filters.gender !== "ALL") {
        processedPenguins = processedPenguins.filter(
          (p) => p.sex === filters.gender
        );
      }

      if (sort?.field) {
        processedPenguins.sort((a, b) => {
          const valA = a[sort.field];
          const valB = b[sort.field];

          if (valA == null) return 1;
          if (valB == null) return -1;

          if (valA < valB) return sort.direction === "asc" ? -1 : 1;
          if (valA > valB) return sort.direction === "asc" ? 1 : -1;
          return 0;
        });
      }

      const totalCount = processedPenguins.length;

      if (pagination) {
        const { page, pageSize } = pagination;
        const start = (page - 1) * pageSize;
        const end = start + pageSize;
        processedPenguins = processedPenguins.slice(start, end);
      }

      return {
        penguins: processedPenguins,
        totalCount,
        totalPages: pagination
          ? Math.ceil(totalCount / pagination.pageSize)
          : 1,
      };
    },
  });
};

/**
 * Custom hook for creating a new penguin.
 * @param {UseMutationOptions<Penguin, Error, PenguinCreateData>} [options] - Options for the mutation.
 * @returns {object} The `useMutation` object for creating a penguin.
 * @throws {Error} If the user is not authenticated.
 */
export const useCreatePenguin = (
  options?: UseMutationOptions<Penguin, Error, PenguinCreateData>
) => {
  const queryClient = useQueryClient();
  const { session } = useAuth();

  return useMutation<Penguin, Error, PenguinCreateData>({
    mutationFn: (penguinData) => {
      if (!session?.accessToken) throw new Error("User is not authenticated.");
      return createPenguin(penguinData, session.accessToken);
    },
    onSuccess: (newPenguin) => {
      queryClient.setQueryData<Penguin[]>(
        PENGUINS_QUERY_KEY,
        (oldData = []) => [newPenguin, ...oldData]
      );
    },
    ...options,
  });
};

/**
 * Custom hook for updating an existing penguin.
 * @param {UseMutationOptions<Penguin, Error, { id: number; penguinData: PenguinUpdateData }>} [options] - Options for the mutation.
 * @returns {object} The `useMutation` object for updating a penguin.
 * @throws {Error} If the user is not authenticated.
 */
export const useUpdatePenguin = (
  options?: UseMutationOptions<
    Penguin,
    Error,
    { id: number; penguinData: PenguinUpdateData }
  >
) => {
  const queryClient = useQueryClient();
  const { session } = useAuth();

  return useMutation<
    Penguin,
    Error,
    { id: number; penguinData: PenguinUpdateData }
  >({
    mutationFn: (vars) => {
      if (!session?.accessToken) throw new Error("User is not authenticated.");
      return updatePenguin({ ...vars, token: session.accessToken });
    },
    onSuccess: (updatedPenguin) => {
      queryClient.setQueryData<Penguin[]>(PENGUINS_QUERY_KEY, (oldData = []) =>
        oldData.map((p) => (p.id === updatedPenguin.id ? updatedPenguin : p))
      );
    },
    ...options,
  });
};

/**
 * Custom hook for deleting a penguin.
 * @param {UseMutationOptions<void, Error, number>} [options] - Options for the mutation.
 * @returns {object} The `useMutation` object for deleting a penguin.
 * @throws {Error} If the user is not authenticated.
 */
export const useDeletePenguin = (
  options?: UseMutationOptions<void, Error, number>
) => {
  const queryClient = useQueryClient();
  const { session } = useAuth();

  return useMutation<void, Error, number>({
    mutationFn: (id) => {
      if (!session?.accessToken) throw new Error("User is not authenticated.");
      return deletePenguin({ id, token: session.accessToken });
    },
    onSuccess: (_, deletedId) => {
      queryClient.setQueryData<Penguin[]>(PENGUINS_QUERY_KEY, (oldData = []) =>
        oldData.filter((p) => p.id !== deletedId)
      );
    },
    ...options,
  });
};
