import {
  QueryKey,
  useInfiniteQuery,
  useMutation,
  UseMutationOptions,
  useQueryClient,
} from "@tanstack/react-query";
import { useAuth } from "./AuthProvider"; // Ensure this path is correct

// --- 1. Constants & Types ---
const API_BASE_URL = process.env.EXPO_PUBLIC_API_BASE_URL;

const PENGUINS_ENDPOINT = `${API_BASE_URL}/penguins`;
const PENGUINS_PER_PAGE = 20;

// Type for the raw data structure from the API
export interface ApiPenguin {
  id: number;
  Species: string;
  Island: string;
  "Beak Length (mm)": number | null;
  "Beak Depth (mm)": number | null;
  "Flipper Length (mm)": number | null;
  "Body Mass (g)": number | null;
  Sex: "MALE" | "FEMALE" | null;
  // --- NEW: Optional name field ---
  Name?: string | null; // API might return it or not
}

// Clean, camelCase type for use within the React application
export interface Penguin {
  id: number;
  species: string;
  island: string;
  beakLengthMm: number | null;
  beakDepthMm: number | null;
  flipperLengthMm: number | null;
  bodyMassG: number | null;
  sex: "MALE" | "FEMALE" | null;
  // --- NEW: Optional name field ---
  name: string | null; // Always present, but can be null
}

// Type for creating a new penguin (id is auto-generated by the server)
// 'name' is now implicitly included via Omit<Penguin, "id">, and it's optional
export type PenguinCreateData = Omit<Penguin, "id">;

// Type for updating a penguin (all fields are optional)
export type PenguinUpdateData = Partial<PenguinCreateData>;

// --- 2. Data Transformation (Mapping) Layer ---

/**
 * Maps the API's format to our clean, internal format.
 * @param apiData The raw penguin object from the API.
 * @returns A clean Penguin object.
 */
const mapApiToPenguin = (apiData: ApiPenguin): Penguin => ({
  id: apiData.id,
  species: apiData.Species,
  island: apiData.Island,
  beakLengthMm: apiData["Beak Length (mm)"],
  beakDepthMm: apiData["Beak Depth (mm)"],
  flipperLengthMm: apiData["Flipper Length (mm)"],
  bodyMassG: apiData["Body Mass (g)"],
  sex: apiData.Sex,
  // --- NEW: Mapping the name field ---
  name: apiData.Name ?? null, // Default to null if not provided by API
});

/**
 * Maps our clean, internal format back to the API's format.
 * @param penguinData The clean penguin data from our app.
 * @returns An object formatted for the API.
 */
const mapPenguinToApi = (
  penguinData: PenguinCreateData | PenguinUpdateData
): Partial<ApiPenguin> => ({
  Species: penguinData.species,
  Island: penguinData.island,
  "Beak Length (mm)": penguinData.beakLengthMm,
  "Beak Depth (mm)": penguinData.beakDepthMm,
  "Flipper Length (mm)": penguinData.flipperLengthMm,
  "Body Mass (g)": penguinData.bodyMassG,
  Sex: penguinData.sex,
  // --- NEW: Mapping the name field ---
  Name: penguinData.name, // Pass null if it's null
});

// --- 3. Core API Fetch Functions (no changes needed here, they use the updated types) ---

const getAuthHeaders = (token: string): HeadersInit => ({
  "Content-Type": "application/json",
  Authorization: `Bearer ${token}`,
});

const fetchPenguinsPage = async (token: string, page: number = 1) => {
  const url = `${PENGUINS_ENDPOINT}?_page=${page}&_per_page=${PENGUINS_PER_PAGE}&_sort=id`;

  const response = await fetch(url, {
    headers: getAuthHeaders(token),
  });

  if (!response.ok) throw new Error("Failed to fetch penguins");

  const totalCount = parseInt(response.headers.get("X-Total-Count") || "0", 10);
  const apiData: ApiPenguin[] = await response.json();
  const penguins = apiData.map(mapApiToPenguin);

  return { penguins, totalCount };
};

const createPenguin = async (
  penguinData: PenguinCreateData,
  token: string
): Promise<Penguin> => {
  const response = await fetch(PENGUINS_ENDPOINT, {
    method: "POST",
    headers: getAuthHeaders(token),
    body: JSON.stringify(mapPenguinToApi(penguinData)),
  });
  if (!response.ok) throw new Error("Failed to create penguin");
  const newApiPenguin: ApiPenguin = await response.json();
  return mapApiToPenguin(newApiPenguin);
};

const updatePenguin = async ({
  id,
  penguinData,
  token,
}: {
  id: number;
  penguinData: PenguinUpdateData;
  token: string;
}): Promise<Penguin> => {
  const response = await fetch(`${PENGUINS_ENDPOINT}/${id}`, {
    method: "PUT",
    headers: getAuthHeaders(token),
    body: JSON.stringify(mapPenguinToApi(penguinData)),
  });
  if (!response.ok) throw new Error("Failed to update penguin");
  const updatedApiPenguin: ApiPenguin = await response.json();
  return mapApiToPenguin(updatedApiPenguin);
};

const deletePenguin = async ({
  id,
  token,
}: {
  id: number;
  token: string;
}): Promise<void> => {
  const response = await fetch(`${PENGUINS_ENDPOINT}/${id}`, {
    method: "DELETE",
    headers: getAuthHeaders(token),
  });
  if (!response.ok) throw new Error("Failed to delete penguin");
};

// --- NEW CUSTOM HOOK: useMutationWithInvalidationLoading (remains the same) ---
function useMutationWithInvalidationLoading<
  TData,
  TError,
  TVariables,
  TContext
>(
  mutationOptions: UseMutationOptions<TData, TError, TVariables, TContext>,
  queryKeyToInvalidate: QueryKey
) {
  const queryClient = useQueryClient();

  const mutation = useMutation<TData, TError, TVariables, TContext>({
    ...mutationOptions,
    onSuccess: (data, variables, context) => {
      mutationOptions.onSuccess?.(data, variables, context);
      queryClient.invalidateQueries({ queryKey: queryKeyToInvalidate });
    },
  });

  const isInvalidatedQueryFetching =
    queryClient.isFetching({ queryKey: queryKeyToInvalidate }) > 0;
  const isPendingCombined = mutation.isPending || isInvalidatedQueryFetching;

  return {
    ...mutation,
    isPending: isPendingCombined,
  };
}

// --- 4. React Query Hooks (no changes needed here, they use the updated types) ---

export const useInfinitePenguins = () => {
  const { session } = useAuth();
  return useInfiniteQuery({
    queryKey: ["penguins"],
    queryFn: ({ pageParam }) =>
      fetchPenguinsPage(session!.accessToken, pageParam),
    initialPageParam: 1,
    getNextPageParam: (lastPage, allPages) => {
      const totalFetched = allPages.length * PENGUINS_PER_PAGE;
      return totalFetched < lastPage.totalCount
        ? allPages.length + 1
        : undefined;
    },
    enabled: !!session?.accessToken,
  });
};

export const useCreatePenguin = () => {
  const { session } = useAuth();
  return useMutationWithInvalidationLoading<
    Penguin,
    Error,
    PenguinCreateData,
    unknown
  >(
    {
      mutationFn: (newPenguin) =>
        createPenguin(newPenguin, session!.accessToken),
    },
    ["penguins"]
  );
};

export const useUpdatePenguin = () => {
  const { session } = useAuth();
  return useMutationWithInvalidationLoading<
    Penguin,
    Error,
    { id: number; penguinData: PenguinUpdateData },
    unknown
  >(
    {
      mutationFn: ({ id, penguinData }) =>
        updatePenguin({ id, penguinData, token: session!.accessToken }),
    },
    ["penguins"]
  );
};

export const useDeletePenguin = () => {
  const { session } = useAuth();
  return useMutationWithInvalidationLoading<void, Error, number, unknown>(
    {
      mutationFn: (id) => deletePenguin({ id, token: session!.accessToken }),
    },
    ["penguins"]
  );
};
